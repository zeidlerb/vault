# packages.yml
#
# packages.yml defines all the packages we are able to build for a single commit
# in this repo. A package means a single zip file containing the executable binary,
# and optionally other files if needed.
#
# packages.yml is a convenience file for the human management of large numbers of
# alternate packages, allowing default and templated values. We generate another
# file from this one, called packages.lock which contains the fully expanded set
# of package specs. This fully expanded file is in turn used to generate CI config
# to build specific sets of packages.
#
# Each package defined by this file is a set of environment variables that are
# passed into the build command 'make package'. See GNUMakefile in this directory.
#
# Note that each package receives an additional entry named PACKAGE_SPEC_ID
# which is the SHA256 sum of a yaml file containing just the entries for that
# specific package. This can be used as part of a cache key for caching packages.
# Note that is is not itself a complete cache key, as the whole source code must be
# taken into consideration, as well as potentially other environmental factors.

# defaults contains default values for each package.
# These values may be overridden on a per-package basis in the packages section.
defaults:
  # PRODUCT_NAME is used as the name of the binary we compile. It should also
  # be used in the PACKAGE_NAME template.
  PRODUCT_NAME: vault

  # PRODUCT_EDITION is an additional differentiator for a given package. It should
  # be used in the PACKAGE_NAME template.
  PRODUCT_EDITION: ""

  # PRODUCT_VERSION is the version of this product. Usually, this should be left
  # as 0.0.0-snapshot. When we build a release candidate, this is overridden in
  # a one-off fashion to produce that build.
  # This should be used in the PACKAGE_NAME template.
  PRODUCT_VERSION: 0.0.0-snapshot

  # GO_VERSION is the version of the Go toolchain to use to compile this package.
  GO_VERSION: 1.12.13

  # YARN_VERSION is the version of Yarn to install for the UI layer.
  YARN_VERSION: 1.19.1-1

  # BUILD_TAGS are passed as-is to the -tag flag of 'go build'. It should be
  # a comma or space separated list, depending on the GO_VERSION you are using.
  BUILD_TAGS: vault

  # Standard golang environment variables, passed to the 'go build' command.
  # You can use any standard environment variables here, any that you omit
  # will be ommitted from the go build command too, meaning to use the system
  # default in the build container.
  CGOENABLED: 0
  GO111MODULE: "off"

# templates contain gomplate template strings. Each of these is rendered per package
# using that packages values (including any default values), and then added to that
# package. To find out more about gomplate, see https://docs.gomplate.ca/
# Note that templates MAY NOT refer to each other.
templates:
  # PRODUCT_VERSION_MMP is just the major.minor.prerelease fields of the PRODUCT_VERSION.
  # Think semantic versioning (semver), although we do not version our binaries
  # using semver.
  PRODUCT_VERSION_MMP: >-
    {{with .PRODUCT_VERSION | strings.SplitN "-" 2}}{{index . 0}}{{end}}
  # PRODUCT_VERSION_PRE is just the prerelease field of the product version (i.e. the bit
  # after any -, if there is one.
  PRODUCT_VERSION_PRE: >-
    {{with .PRODUCT_VERSION | strings.SplitN "-" 2}}{{if gt (len .) 1}}{{index . 1}}{{else}}"''"{{end}}{{end}}
  # BUNDLE_NAME is the name of the release bundle this package belongs to.
  # All packages with the same BUNDLE_NAME are considered part of the same release
  # bundle, and are placed in the same directory on releases.hashicorp.com, as well
  # as sharing a SHASUMS file.
  BUNDLE_NAME: >-
    {{.PRODUCT_NAME}}_{{.PRODUCT_VERSION}}{{if .PRODUCT_EDITION}}+{{.PRODUCT_EDITION}}{{end}}
  # PACKAGE_NAME is the name of a specific package. Care must be taken to ensure this
  # is unique per package. The final zip file we produce per package uses this name.
  PACKAGE_NAME: >-
    {{.PRODUCT_NAME}}_{{.PRODUCT_VERSION}}{{if .PRODUCT_EDITION}}+{{.PRODUCT_EDITION}}{{end}}_{{.GOOS}}_{{.GOARCH}}
  # BUILD_JOB_NAME is the name of a job to build this package in CI. Care must be
  # taken that it is both unique within this set of packages, as well as compatible
  # with the CI system's naming conventions.
  BUILD_JOB_NAME: >-
    package_{{if .PRODUCT_EDITION}}{{.PRODUCT_EDITION}}_{{end}}{{.GOOS}}_{{.GOARCH}}

# packages is the full set of packages we are able to build based on a single commit
# in this repo. Each package is a map where the keys are the names of environment
# variables provided to each build (think 'go build' invocation). Each package is
# expanded by first filling in any unspecified variables with those from defaults,
# and then rendering each template and adding the result to the map.
# Each package must result in a unique PACKAGE_NAME.
#
# The fully expanded set of packages are written to packages.lock. That file
# is a useful data source for building CI/CD pipelines.
packages:
  - { GOOS: darwin, GOARCH: 386 }
  - { GOOS: darwin, GOARCH: amd64 }
  - { GOOS: freebsd, GOARCH: 386 }
  - { GOOS: freebsd, GOARCH: amd64 }
  - { GOOS: freebsd, GOARCH: arm }
  - { GOOS: linux, GOARCH: 386 }
  - { GOOS: linux, GOARCH: amd64 }
  - { GOOS: linux, GOARCH: arm }
  - { GOOS: linux, GOARCH: arm64 }
  - { GOOS: netbsd, GOARCH: 386 }
  - { GOOS: netbsd, GOARCH: amd64 }
  - { GOOS: openbsd, GOARCH: 386 }
  - { GOOS: openbsd, GOARCH: amd64 }
  - { GOOS: solaris, GOARCH: amd64 }
  - { GOOS: windows, GOARCH: 386 }
  - { GOOS: windows, GOARCH: amd64 }

# Layers determines the build layers, which are individually cacheable layers
# in a linear build. Each layer contains a partial Dockerfile. All the layers
# together produce the final builder image used to compile binaries.
#
# The partial Dockerfiles may contain references to any of the variables
# including rendered template variables. The checksum of the cumulative
# layers up to each layer is calculated using the source included as well
# as the rendered Dockerfile. Thus you can control cacheability by careful
# use of variables. It is recommended not to use any variables that vary per-
# package in these Dockerfiles, as that enables a single docker image to be
# produced per set of packages.
#
# The order of layers is significant. The first layer must have a FROM line, and
# forms the base image. Each subsequent layer begins from the previous one.
layers:
  - name: base
    source-include: ""
    source-exclude: ""
    dockerfile: |-
      FROM debian:buster
      RUN apt-get update -y && apt-get install --no-install-recommends -y -q \
                               curl \
                               zip \
                               build-essential \
                               gcc-multilib \
                               g++-multilib \
                               ca-certificates \
                               git mercurial bzr \
                               gnupg \
                               libltdl-dev \
                               libltdl7 \
      						             bash
      RUN curl -sL https://deb.nodesource.com/setup_10.x | bash -
      RUN curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add -
      RUN echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list
      RUN apt-get update -y && apt-get install -y -q nodejs yarn={{.YARN_VERSION}}
      RUN rm -rf /var/lib/apt/lists/*

      ENV GOPATH /gopath
      ENV GOROOT /goroot

      RUN mkdir $GOROOT && mkdir $GOPATH

      RUN curl https://storage.googleapis.com/golang/go{{.GO_VERSION}}.linux-amd64.tar.gz \
                 | tar xvzf - -C $GOROOT --strip-components=1

      ENV PATH $GOROOT/bin:$GOPATH/bin:$PATH

      RUN go get golang.org/x/tools/cmd/goimports
      RUN go get github.com/mitchellh/gox
      RUN go get github.com/hashicorp/go-bindata
      RUN go get github.com/hashicorp/go-bindata/go-bindata
      RUN go get github.com/elazarl/go-bindata-assetfs
      RUN go get github.com/elazarl/go-bindata-assetfs/go-bindata-assetfs

      ENV REPO=github.com/hashicorp/vault
      ENV DIR=$GOPATH/src/$REPO

      RUN mkdir -p $DIR

      WORKDIR $DIR

  # Because each layer is a small, separate Dockerfile, rather than a cumulative
  # Dockerfile, we add a comment to each one, containing the checksum of the
  # underlying one. This ensures that any changes to underlying Dockerfiles will
  # result in new subsequent Dockerfilees. This is important because when
  # calculating the source ID, we must also take into consideration the source
  # of the Docker container we are building in. By having the checksums flow
  # through the source, we are able to just take just the last layer's
  # Dockerfile into consideration, rather than all of them.
  # The comments look like this:
  #
  #     # Base layer checksum: {{env.Getenv "BASE_LAYER_CHECKSUM"}}
  #
  # Note that the source ID of the _images_ built using these Dockerfiles
  # is additionally dictated by the source included in that layer.
  - name: yarn
    source-include: ui/package.json ui/yarn.lock
    source-exclude: ""
    dockerfile: |-
      # Parent layer checksum: {{env.Getenv "BASE_LAYER_CHECKSUM"}}
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN cd ui && yarn install
      RUN cd ui && npm rebuild node-sass
  - name: ui
    source-include: ui/
    source-exclude: ""
    dockerfile: |-
      # Parent layer checksum: {{env.Getenv "BASE_LAYER_CHECKSUM"}}
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN cd ui && yarn run build
  - name: static
    source-include: .
    source-exclude: .circleci/ release/
    dockerfile: |-
      # Parent layer checksum: {{env.Getenv "BASE_LAYER_CHECKSUM"}}
      ARG BASE_IMAGE
      FROM $BASE_IMAGE
      COPY . ./
      RUN make static-assets
